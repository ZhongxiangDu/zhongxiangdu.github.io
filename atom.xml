<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Du&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.duzhongxiang.com/"/>
  <updated>2016-12-30T19:30:10.000Z</updated>
  <id>http://www.duzhongxiang.com/</id>
  
  <author>
    <name>Zhongxiang Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux Start Part II</title>
    <link href="http://www.duzhongxiang.com/2016/09/19/Linux-Start-Part-II/"/>
    <id>http://www.duzhongxiang.com/2016/09/19/Linux-Start-Part-II/</id>
    <published>2016-09-19T07:58:00.000Z</published>
    <updated>2016-12-30T19:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>As the Linux booting process is very long, the <a href="/2016/09/18/Linux-Start/" title="article">article</a> has talked some prepared work in the <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Protected Mode">Protected Mode</a> and this article will briefly talk about the follow-up work of the booting process.<a id="more"></a></p>
<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><p>After the Head has build the <a href="/2016/09/10/Paging/" title="Paging">Paging</a> system, the kernel will jump to Main, after the part most of the code are writen by C language. In Main, many initiation works are done.</p>
<ol>
<li>Read the computer information in 0x90000~0x901FD stored by Setup.</li>
<li>Set ramdisk, if RAMDISK is defined in Makefile, alloc RAMDISK KB in 0x3FFFFF for ramdisk.</li>
<li>As Linux 0.11 only support 16MB, here define an array mem_map to denote whether the pages denoting 1MB~16MB are used.</li>
<li>Register all the ISR in the <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="IDT">IDT</a>.</li>
<li>Initiate the <a href="/2016/09/18/Buffer-and-Block-Device/" title="Block Device request array">Block Device request array</a>.</li>
<li>Set the serial port, the IRQ3 and IRQ4 of interrupt controller (8259A) is for RS232 serial communication. Initiate the console, setting the information about the monitor. Then, add keyboard ISR. More details please refer to <a href="/2016/09/12/TTY/" title="TTY">TTY</a>.</li>
<li>Read the current time from a CMOS in the mainboard and transfer it into the system start-up time.</li>
<li>Set the current task as process 0, and initiate the zero item in <a href="/2016/09/12/Fork-and-Execve/" title="task[64]">task[64]</a>. Load the current <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="TSS">TSS</a> and <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="LDT">LDT</a> into <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="GDT">GDT</a>.</li>
<li>Register timer interrupt and set interval as 10ms. For more details please refer to <a href="/2016/09/18/Scheduler-and-Timer/" title="Scheduler and Timer">Scheduler and Timer</a>.</li>
<li>Register the system call interrupt, the user process can not access the kernel, but the user need to read file or print information in many cases. So the kernel offers a set of system calls. When user use this functions, it will trigger an interrupt.</li>
<li>Initiate the <a href="/2016/09/18/Buffer-and-Block-Device/" title="Buffer">Buffer</a>.</li>
<li>Initiate the floppy and hard disk. Here, the kernel just simply register the ISR for the device.</li>
<li>Enable the interrupt and jump to the user mode by using the stack.</li>
</ol>
<h4 id="Process-1"><a href="#Process-1" class="headerlink" title="Process 1"></a>Process 1</h4><p>After entering the user mode, the process 0 will <a href="/2016/09/12/Fork-and-Execve/" title="fork">fork</a> process 1. After this, the process 0 will “sleep”(even though process 0 will take part in the scheduling, it will do nothing).</p>
<p>The first work of process 1 is calling the system call sys_setup(this can only be called once) to load the root file system. sys_setup will spend a lot of time to verify the information of the devices. Based on the root device number, read the data from the corresponding data, read the 257,256,258 data blocks. The super block is 257. After verifying the super block, read the whole root file system into 0x3FFFFF, and set it as root device. Initiate the file manage table, file_table[64], so Linux 0.11 can open at most 64 files at the same time. Because after loading the root file system, all the operations to the devices is by <a href="/2016/09/13/File-Operation/" title="File Operation">File Operation</a>. Initiate the super block management table.</p>
<p>Read the super block inode and the file system inode, and add the super block to the super block management table. Because the root file system is in the memory now, these operations will not trigger any interrupts. Set the root directory’s inode as the inode of the root file system. Here the root file system is loaded.</p>
<p>Open the file dev/tty0, which means the console, as this is first opening file operation, the file descriptor must be 0. For more details please refer to <a href="/2016/09/13/File-Operation/" title="File Operation">File Operation</a>. Then copy the file descriptor twice, for stdout and stderr.</p>
<h4 id="Process-2"><a href="#Process-2" class="headerlink" title="Process 2"></a>Process 2</h4><p>Process 1 use system call fork and create process 2. Process 2 inherits all the information from process 1 and close the file descriptor 0 (stdin) and open /etc/rc as input, then execute a shell program and the rc file is the input to the shell program, which start the process <a href="/2016/09/13/File-Operation/" title="update">update</a>. While the shell is running, the process 1 is always waiting.<br>When this shell program is end, process 1 will start a new shell program, at this time it will use the /dev/tty0 as stdin. In this case, we can input the command by the keyboard and start new processes with this commands.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;As the Linux booting process is very long, the &lt;a href=&quot;/2016/09/18/Linux-Start/&quot; title=&quot;article&quot;&gt;article&lt;/a&gt; has talked some prepared work in the &lt;a href=&quot;/2016/08/21/Protected-mode-and-Real-mode/&quot; title=&quot;Protected Mode&quot;&gt;Protected Mode&lt;/a&gt; and this article will briefly talk about the follow-up work of the booting process.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Linux Start</title>
    <link href="http://www.duzhongxiang.com/2016/09/18/Linux-Start/"/>
    <id>http://www.duzhongxiang.com/2016/09/18/Linux-Start/</id>
    <published>2016-09-19T05:04:50.000Z</published>
    <updated>2016-12-30T19:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>This article mainly talks about the details of booting process of Linux 0.11. It focuses on the initiation work in the <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Real Mode">Real Mode</a> and some prepared work in the <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Protected Mode">Protected Mode</a>. In this part, all the code is written by assembly language<a id="more"></a></p>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><p>When we turn on the computer, the CPU is in <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Real Mode">Real Mode</a>, so the addressing range is 1MB and there is nothing in the RAM. So this part is done by the hardware. The memory 640KB~1MB is used for the ROM and the BIOS is in the ROM. The the CS register is set as 0xFFFF, and IP is set as 0x0000. At this time the CS:IP is 0xFFFF0, and this is the entry of BIOS.</p>
<p>Bios will create its IVT (Interrupt Vector Table) and ISR (Interrupt Service Routine) and read the information of the computer and store them in certain address of the memory. At last BIOS will load the first 512 byte of the disk to 0x07C000 and strat to execute from this address.</p>
<h4 id="Bootsect"><a href="#Bootsect" class="headerlink" title="Bootsect"></a>Bootsect</h4><p>Bootsect is the 512 bytes BIOS just read from the disk. Here, Bootsect will copy itself from 0x07C000 to 0x90000 and execute from the new address. And set the SS (Stack Segment Register) as 0x9000 and SP (Stack Pointer) as 0xFF00. Setting SS and SP as these values can reserve enough space for stack operation (push and pop) and later interrupt operations will take advantages of the stack.</p>
<p>Then, Bootsect will read the Setup program into the memory 0x90200 (the 0x200 is just 512 bytes). To read the Setup, Bootsect will use the IVT and ISR created by BIOS to read from the disk. Use the interrupt “int 0x13” to read Setup (4 sectors, 2KB). Then loadd the other parts of the system to 0x10000 in the same way (240 sectors, 120KB). As it takes some time to load the system, “Loading system …” is printed on the screen by using the 0x10 interrupt. Then Bootsect will load the root device number and store it in 0x901FC, in case load the root file system later.</p>
<h4 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h4><p>Setup will fisrt use the interrupt to get the computer information and store them in 0x90000~0x901FD, and this operation will cover some parts of Bootsect. Then Setup disables all the interrupts by setting the IF bit of EFLAGS Register as 0. Because the later operation will cover the memory of the IVT and ISR created by BIOS, if interrupts occurs at that time, unexpected error may happen.</p>
<p>Then Setup will move the system (240 sectors loaded by Bootsect) from 0x10000 to 0x00000, which will cover the IVT and ISR created by BIOS. Because the next step will turn to <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Protected Mode">Protected Mode</a>, new <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="IDT">IDT</a> and <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="GDT">GDT</a> should be set ahead. Here, the <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="GDTR">GDTR</a> is set as 0x90200 and write the data to this address. Based on the structure of GDT, the zero item is empty, first item is the kernel code segment descriptor, second item is the kernel data segment descriptor. The base address of the kernel code segment and kernel data segment are 0x00000000 and IDTR is also 0x00000000 (because no ISR has been added and the system is still in Real mode, so it does not cover the system in the 0x00000).</p>
<p>The Setup will open the A20, which means the CPU can do 32-bit addressing. Before opening the A20, only 0~19 pins of CPU can be used for addressing. When the address is out of 0xFFFFF, it will return from 0x00000. After opening A20, the 20~31 pins of CPU can be used for addressing. But this does not means, we are in <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Protected Mode">Protected Mode</a> now. Then the Setup will reprogram the interrupt controller (8259A), which will not change any data in the memory and just do some initiation work for the 8259A. </p>
<p>Set the CR0 register as 0 that the system has entered the <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Protected Mode">Protected Mode</a>. As the system is using a new addressing method now, the code below means select the first item of the GDT and the offset is 0. In another words, the next operation will start from the address 0x00000000 as the base address of the first item in the GDT is 0x00000000.</p>
<pre><code>jmpi    0, 8
</code></pre><p>Remember the Setup has moved the system’s code to this address.</p>
<h4 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h4><p>Just comparing the code in head.s and setup.s, we can find the code style has changed a lot. Because they are executed in different mode. The first work of Head is resetting the register used in Read mode, setting the DS, ES, FS, GS as 0x10 which means they will point to the second item of the GDT (kernel data segment descriptor). As the SS and SP can not work in <a href="/2016/08/21/Protected-mode-and-Real-mode/" title="Protected Mode">Protected Mode</a>, SS is also set as 0x10, ESP is the new Stack Poniter point to the end of user_stack (an array defined in sched.c exists in the kernel’s data segment).</p>
<p>Then Head will reset the <a href="/2016/09/11/IDT-LDT-TSS-and-GDT/" title="IDT">IDT</a> by setting the IDTR as idt (an structure array defined in head.h, also exists in the kernel’s data segment) and set all the ISR in IDT as ignore_int, unknown iterrupt. Then reset the GDT by setting GDTR as gdt (an structure array defined in head.h, also exists in the kernel’s data segment), Because the memory of the old GDT will be used as <a href="/2016/09/18/Buffer-and-Block-Device/" title="Buffer">Buffer</a>. Compared to the old GDT, the content in the new one does not change, except the limit becomes 16MB. </p>
<p>Last, the Head will build a <a href="/2016/09/10/Paging/" title="Paging">Paging</a> system, that it will create a page content at the begin of the physical memory and 4 page tables after the directory. The first 4 items in the directory point to the 4 tables and 4 tables manage the first 16MB memory (4096*4KB). Set CR3 as 0x00000000 (address of page directory) and set the PG bit of CR0 as 1, which means enable Paging. The code later will use the Paging system. Because for the kernel the linear address is the same to the physical address, so we can still find the code like directly reading 0x901FC to get the root device number.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This article mainly talks about the details of booting process of Linux 0.11. It focuses on the initiation work in the &lt;a href=&quot;/2016/08/21/Protected-mode-and-Real-mode/&quot; title=&quot;Real Mode&quot;&gt;Real Mode&lt;/a&gt; and some prepared work in the &lt;a href=&quot;/2016/08/21/Protected-mode-and-Real-mode/&quot; title=&quot;Protected Mode&quot;&gt;Protected Mode&lt;/a&gt;. In this part, all the code is written by assembly language
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Buffer and Block Device</title>
    <link href="http://www.duzhongxiang.com/2016/09/18/Buffer-and-Block-Device/"/>
    <id>http://www.duzhongxiang.com/2016/09/18/Buffer-and-Block-Device/</id>
    <published>2016-09-18T23:17:16.000Z</published>
    <updated>2016-09-19T08:29:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>In Linux 0.11, the all kinds of reading/writing operations are done with the help of buffer. Every changes is reflected on the buffer and then synchronize with devices.<a id="more"></a></p>
<h2 id="Buffer-Management"><a href="#Buffer-Management" class="headerlink" title="Buffer Management"></a>Buffer Management</h2><p>In the initiation step, the system will reserve the memory between the “end” of kernel and 0x3FFFFF (except the 0x9FFFF to 0xFFFFF for BIOS and VGA) for buffer. The “end” of kernel is an external variable setted by ld in linking, so we can not find the define of the symbol. The memory for buffer is devided into many 1KB buffer blocks. A hash table with 307 buckets and a double linked list are used to manage all the buffer blocks. Each buffer block has a device number and block number, denoting the device and corresponding data in this device. And the device number and block number are used to calculate the hash value to quickly find the buffer block. Except the data, each buffer block has some flags denoting the status for multi processes visiting and device synchronization.</p>
<h2 id="Block-device"><a href="#Block-device" class="headerlink" title="Block device"></a>Block device</h2><p>Linux 0.11 only support 3 kinds of devices, floppy, hard disk and ramdrive. Ramdrive is in the memory so it is very easy to operate. But floppy and hard disk are much more complicated that they have a lot of seeking and synchronization operations. Here we don’t talk about how to read/write a certain block device and we focus on the interaction between block devices and buffer.</p>
<p>The Linux 0.11 has an block device request list for reading and writing operations. The length of the list is 32 (As most of the operations are reading, $2/3$ of the items in the list are for reading and the other $1/3$ are for writting). Every device operations must register the request list and then read or write the buffer blocks, except the two conditions: </p>
<ol>
<li>For writing operation, the data in the buffer block has not been changed, since it is read from the device.</li>
<li>For reading operation, the data in the buffer block has already been updated and it is the same to the data in the device.</li>
</ol>
<p>When the request list is full, the current will sleep, waiting for an unused request item. When there is available request item in the list, check whether the device has other requests. If it has, push the request into the queue. The system will process all the requests in the queue, one by one, until the queue is empty.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In Linux 0.11, the all kinds of reading/writing operations are done with the help of buffer. Every changes is reflected on the buffer and then synchronize with devices.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Scheduler and Timer</title>
    <link href="http://www.duzhongxiang.com/2016/09/18/Scheduler-and-Timer/"/>
    <id>http://www.duzhongxiang.com/2016/09/18/Scheduler-and-Timer/</id>
    <published>2016-09-18T22:07:11.000Z</published>
    <updated>2016-12-30T22:52:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Task scheduling is the core part of an operation system. It is extremely important but need not to be very complicated. In many cases, simple scheduling policy can improve the system efficiency.<a id="more"></a> Personally speaking, there is not the best scheduling policy but the most suitable scheduling policy.</p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>The Scheduler and timer are two indivisible concepts in operation system. In Linux 0.11, in the initiation step, the system will set an timer which will time out in every 10ms. Every 10ms, the system will execute the ISP, and execute all the functions registered by different processes. Minus the time slices (counter, the default value of counter is the process’s priority) by 1.</p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>Before the real task scheduling in Linux 0.11, the system will deal with all the alarms. For the process which has set an alarm and the alarm is time out, the kernel will send an alarm message to the processes and based on the current status of the processes, wake up the processes (set them into Ready status). Find the process with the biggest counter in Ready status, then jump to this process. If the biggest counter is 0, update all the counters. The policy is $counter = counter/2 + priority$ and after the update, find the process with the biggest counter in Ready status.</p>
<p>The task state transition diagram is shown below.<br><img align="center" src="/images/TaskGraph.svg" width="60%" height="60%"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Task scheduling is the core part of an operation system. It is extremely important but need not to be very complicated. In many cases, simple scheduling policy can improve the system efficiency.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Pipe and Signal</title>
    <link href="http://www.duzhongxiang.com/2016/09/17/Pipe-and-Signal/"/>
    <id>http://www.duzhongxiang.com/2016/09/17/Pipe-and-Signal/</id>
    <published>2016-09-17T07:41:07.000Z</published>
    <updated>2016-09-19T05:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pipe and signal are two common technology to do processes communication. And Linux 0.11 has supported both of them. Here are the brief introduction to the implemention of the them.<a id="more"></a></p>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>Pipe can only be used between processes with kinship (father and child processes). In Linux 0.11, pipe is a memory page shared by two processes. When the father process creates an pipe, it equals to opening a file twice, and getting two file descriptors. One is for reading and the other is for writing. But the inode used here is not pointing to a virtual disk or disk. This is a pipe inode. Even though it is an inode, but it has totally different meaning. Its i_size points to an memory page which means a 4KB buffer, i_zone[0] and i_zone[1] means the head and tail of the buffer.</p>
<p>Reading/writing operation is done by move the head/tail pointer and then read/write data. When the buffer is full or empty, the current process will fall asleep.</p>
<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Linux 0.11 supports 32 kinds of signals and in the process task structure, there is a structure array sigaction[32], corresponding to the signal and its functions (handle and recover). When we call the system call signal(), the program will register the functions for the signal.</p>
<p>Linux 0.11 sends signals by calling function kill(). This function will sent signal to a process or process group (not just kill them). Sending signal means set the corresponding bit of the process. During the scheduling, the kernel will check all the signals and set the processes with at least one signal into Ready status. When the processes in Ready status begin to execute and timing out happens or system call is called, it will execute the signal handle function. So the handle function is executed in the kernel. After executing the handle function, the system will call the<br>sa_restorer function. This function does not exist in the kernel code, and is not written by the programmer. It is provided by the libc library and the compiler will integrate it into the program. The sa_restorer function will recover the environment of the process.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pipe and signal are two common technology to do processes communication. And Linux 0.11 has supported both of them. Here are the brief introduction to the implemention of the them.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Minix 1.0</title>
    <link href="http://www.duzhongxiang.com/2016/09/15/Minix-1-0/"/>
    <id>http://www.duzhongxiang.com/2016/09/15/Minix-1-0/</id>
    <published>2016-09-15T16:41:23.000Z</published>
    <updated>2016-09-19T04:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>The file system of Linux 0.11 is Minux 1.0, this is very tiny file system with limited capacity. But it is very suited to be an eductional version.<a id="more"></a></p>
<p>The Minux 1.0 devides the device by 1KB per block. The first block is the boot block. To make sure the unity of the file format, this block can contain no content, but it must exist. The second block is the super block, it has the basic information about the current file system, for example the maximum number of the inode, the maximum number of the logical block, size of the inode bitmap and the size of the logical block bitmap.<br>Here are the explanation to this concepts.</p>
<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>In the minix 1.0, every file has its inode. In the inode there are the file type, length, modification time, user, user group and the logical block numbers that the file has occupied. These logical block numbers are stored in a array i_zone[9], i_zone[0] to i_zone[6] are the direct block numbers, which means they directly point to the data blocks. i_zone[7] is one order block number that it point to a logical block and in this block, there are the the direct block numbers. And i_zone[8] is two order block number that it point to a logical block and in this block, there are the the one order block numbers.</p>
<p>As each block is represented by a 2-byte short number, each block can store at most 512 block numbers (the size of one block is 1KB). So, the Minix 1.0 can support $7 + 512 + 512*512 = 262,663$KB.</p>
<p>In Minix 1.0, the directory is also a kind of file. In the data blocks of the directory, there are the files’ names and inode numbers. All the information about the inodes is stored in the blocks between the end of logical block bitmap and the start of the logical block.</p>
<h2 id="inode-bitmap"><a href="#inode-bitmap" class="headerlink" title="inode bitmap"></a>inode bitmap</h2><p>Normally, the inode bitmap will take 8 blocks, which is 65,536 bits. The first bit is not used. So, in this case, Minix 1.0 can support at most 65,535 inodes. With the inode bitmap, the system can find the unused inode in no time. So it can help to speed up the creating file operation.</p>
<h2 id="logical-block"><a href="#logical-block" class="headerlink" title="logical block"></a>logical block</h2><p>Logical blocks are mainly used to store the data of the files. In super block, there is a number denoting the start position of the logical block.</p>
<h2 id="logical-block-bitmap"><a href="#logical-block-bitmap" class="headerlink" title="logical block bitmap"></a>logical block bitmap</h2><p>Just like inode bitmap, the logical block bitmap stores the information about whether a logical block has been used. This bitmap can take at most 8 blocks. So, the Minix 1.0 supports at most 65,536 block which means Minix 1.0 supports a device with at most 64MB.</p>
<p>With the device number and the block number in the device, the system can operate the corresponding block of the device.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The file system of Linux 0.11 is Minux 1.0, this is very tiny file system with limited capacity. But it is very suited to be an eductional version.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="File System" scheme="http://www.duzhongxiang.com/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>File Operation</title>
    <link href="http://www.duzhongxiang.com/2016/09/13/File-Operation/"/>
    <id>http://www.duzhongxiang.com/2016/09/13/File-Operation/</id>
    <published>2016-09-13T07:27:19.000Z</published>
    <updated>2016-09-19T04:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>This article mainly focuses on the create, read, write, close and delete operations on file in Linux 0.11. Here is only a brief view of the steps.<a id="more"></a> </p>
<h2 id="Create-File"><a href="#Create-File" class="headerlink" title="Create File"></a>Create File</h2><p>In C Programing Language, by calling fopen() function we can open or create a file. The first parameter of fopen() is the path of the file. With this path, the system will start from the inode of the root or current directory. By looking into the i_zone in the inode, system will find the file inode or the inode of the file directory (when the file does not exist, which means we will create a file in this directory). Here we only talk about creating file.</p>
<p>Firstly, we need to create a inode in the directory. We find an empty item on the inode list–inode_table[32]. The inode_table[32] denotes the currently being used files (in Linux 0.11, the whole system can only open st most 32 files at the same time). If there is no empty item in inode_table[32], the process will sleep to wait. Using the inode bitmap to find the unused inode number, if all the number have been used, return failed to create file. Binding the empty item in inode_table[32] with the inode and add file name and inode number to the i_zone of the directory inode. Note: here we have not write the file to the disk, we just write the file to the buffer block. Then the system bind the new inode with one unused item in filp[20] of the current process. In every process’s task structure, there is an array filp[20] denoting the files being opened by the process. In Linux each process can open at most 20 files at the same time. And the normal return value of fopen() is the index of the file in filp[20].</p>
<h2 id="Read-Write-File"><a href="#Read-Write-File" class="headerlink" title="Read/Write File"></a>Read/Write File</h2><p>With the fd returned by the fopen(), we can find the inode of the file. And using the i_zone of the inode, we can find the block number of the disk. For reading operation, we directly read the data on the disk to the buffer block, and then copy this data to the buffer of the user process. For the writing operation, we write the data to the buffer block.</p>
<h2 id="Close-File"><a href="#Close-File" class="headerlink" title="Close File"></a>Close File</h2><p>This is simple operation, when we calls the fclose() function. The system will unbind the file inode with the corresponding item of filp[20]. If there is still some asynchronous data about the file, the system will synchronize this data to the buffer block.</p>
<h2 id="Delete-File"><a href="#Delete-File" class="headerlink" title="Delete File"></a>Delete File</h2><p>By using the system call unlnk(), we can delete a file. With the input path, we can find the file inode and directory inode. We set the inode number of the corresponding file in the i_zone of directory inode as 0. So we can not asscee the file by path. And then minus the i_nlink of the file inode by 1, and synchronize these changes to the buffer block. At this time, the file has not been deleted, because the file inode is still on the disk, and we has not changed the logical block bitmap has not been changed. Only when the i_nlink becomes 0, the file will be deleted.</p>
<p>When the i_nlink becomes 0, the system will find the logical block number of the file data and make them available and then release the inode number from the inode bitmap.</p>
<h2 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h2><p>All the operations we have talked about have not change the disk. All the changes are on the buffer block. The system will synchronize the buffer block with the disk in two conditions.</p>
<ol>
<li>Update process. When the system execute the shell process for the first time. The shell will start a update process, the process will synchronize the buffer block with the disk once in a while.</li>
<li>When the system is running out of buffer (some buffer blocks have been written, but not been used right now), the system will synchronize all the buffer blocks with the disk.</li>
</ol>
<p>Synchronization has two steps:</p>
<ol>
<li>Write the data of inode_table[32] to buffer blocks;</li>
<li>Write the data in all the buffer blocks to disk.</li>
</ol>
<p>In condition 1, the synchronization will be executed at order of 1,2. In condition 2, the synchronization will be executed at order of 2,1,2. Because step 1 will write data to the buffer block, but the system is running out of buffer at this time. So, it will clear the buffer first.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This article mainly focuses on the create, read, write, close and delete operations on file in Linux 0.11. Here is only a brief view of the steps.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="File System" scheme="http://www.duzhongxiang.com/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>Fork and Execve</title>
    <link href="http://www.duzhongxiang.com/2016/09/12/Fork-and-Execve/"/>
    <id>http://www.duzhongxiang.com/2016/09/12/Fork-and-Execve/</id>
    <published>2016-09-13T00:23:35.000Z</published>
    <updated>2016-09-19T04:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>This article mainly focuses on the two system calls, fork and execve, in Linux 0.11 and describes what will happen when we call them. <a id="more"></a> </p>
<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>In Linux programing, fork is one of most widely used functions. Fork will create a same process as the current process. <!-- more -->Based on the return value of the fork function, we can decide whether we are in the father process or child process. Fork is a system call, that calling this function will trigger a soft interrupt and the kernel will do the next jobs.</p>
<p>In Linux0.11, kernel will try to find a used item in array task[64]. If all the array is full, fork will return an error EAGAIN, which means the number of processes has reached its limit, please try again. Linux 0.11 supports at most 64 processes coexisting at the same time. And each process’s segment descriptor’s base address is 64MB $\times$ [the index in array task]. Based on this, kernel will add the new process’s code segment descriptor and data segment descriptor into GDT.</p>
<p>Once a process has been created, kernel will malloc a page to store the process’s task structure and store the current registers’ values into the TSS structure in task structure. This step is very important, because without this, the child may run the fork function again. Then the kernel set the return value into EAX register to make sure the father and child have different return values.</p>
<p>Based on the sgement limit of the father process, kernel will copy the page directory and page table to new process and put them at the begin of the linear address. So even the father and child process use different page directory and page table, but they use the same physical page. As the same page is being used by two processes, kernel set the page as read only, and add the page’s count by 1.</p>
<p>As the child process’s task structure is directly copied from its father, the child process has its father’s file and other resources. So the kernel will add the counts of these resources by 1.</p>
<h2 id="Execve"><a href="#Execve" class="headerlink" title="Execve"></a>Execve</h2><p>In Linux programing, fork and execve are usually used together, using fork create a process and calling execve to open an executable file.</p>
<p>After calling the fork system call, child and father process nearly shared all the resources. Like fork, execve is also a system call. In this system call, it will first malloc 32 pages (128KB) to store the environment values. Based on the file path, find the inode of the executable file and check the validity of this file. After the checking, put the environment values in the 32 pages. Change the current executable file into the new executable file (note: process 0 and process 1 have no executable file). Then close  the resources (including the shared pages) of the father process by minus the counts of them by 1.</p>
<p>Read the information of the executable file head. Based on this information set the new code segment limit and data segment limit and insert the pages, storing the environment values, into the end of the data segment and create a table to manage these values. Set the stack pointer and code pointer.</p>
<p>After finished all these perpared work, when the process is waken up again, it will run in a new code segment, and this page is missing. In this case, it will trigger an interrupt, mallocing a new page and read the code from the executable file. If in the system, there is another process executing the same executable file, these processes will share the same pages.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This article mainly focuses on the two system calls, fork and execve, in Linux 0.11 and describes what will happen when we call them.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>TTY</title>
    <link href="http://www.duzhongxiang.com/2016/09/12/TTY/"/>
    <id>http://www.duzhongxiang.com/2016/09/12/TTY/</id>
    <published>2016-09-12T18:39:36.000Z</published>
    <updated>2016-09-19T05:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>TTY comes from the word teletypes or teletypewriters, means the physical or virtual interrupt. TTY mainly focuses on interactive with user.<a id="more"></a></p>
<p>In Linux 0.11, there are 3 TTYs, one is for the keyboard typing and screen display and the other 2 ttys are for RS232 serial port input/output. Every TTY has 3 buffering queue, read-queue, write-queue and secondary queue. Here we focus on the keyboard TTY, the RS232 TTY is similar to keyboard TTY. They differences are the input and output device.</p>
<p>When we turn on the computer, the system will add a keyboard ISR in the IDT. While a key has been pressed, the CPU will execute the keyboard ISR. The keyboard ISR will put the code of the key into read-queue. And then, loop over all the data in the read-queue, standardizing the code and putting the standardized code into secondary queue, until the read-queue is empty or the secondary queue is full.</p>
<p>We can not only type letters or numbers but also input some control characters, for example, delete or enter. When we have entered a control character, for example, “delete”, the system will delete the last character in the secondary queue (all the synchronized operations are reflected in the secondary queue). In many cases, the echo flag will be setted. If the echo flag has been setted, the system will also put the standardized code into write-queue, and display the characters on the screen by looping over the write-queue and taking out every character. After the keyboard ISR, the system will wake up the process which is waiting for the TTY.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TTY comes from the word teletypes or teletypewriters, means the physical or virtual interrupt. TTY mainly focuses on interactive with user.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>IDT LDT TSS and GDT</title>
    <link href="http://www.duzhongxiang.com/2016/09/11/IDT-LDT-TSS-and-GDT/"/>
    <id>http://www.duzhongxiang.com/2016/09/11/IDT-LDT-TSS-and-GDT/</id>
    <published>2016-09-11T22:36:23.000Z</published>
    <updated>2016-09-19T04:59:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>In Linux, there are many similar concepts. This article briefly talks about the IDT (Interrupt Descriptor Table), GDT (Global Descriptor Table), LDT (Local Descriptor Table) and TSS(Task State Segment).<a id="more"></a></p>
<h2 id="IDT-Interrupt-Descriptor-Table"><a href="#IDT-Interrupt-Descriptor-Table" class="headerlink" title="IDT (Interrupt Descriptor Table)"></a>IDT (Interrupt Descriptor Table)</h2><p>The whole system has only one IDT. In protected mode, IDT stores the address of all the ISR (Interrupt Service Routine). When interrupt happens, the system will directly find the corresponding ISR, with the help of IDT. It has similar function compared to the IVT (Interrupt Vector Table) in real mode. Their differences are that IVT has a fixed address but IDT’s address is stored in IDTR (Interrupt Descriptor Table Register) and it can be changed. Using the command,</p>
<pre><code>lidt [idt_48]
</code></pre><p>we can write the address of IDT into IDTR. In IDT, there are many Interrupt Gate, each Interrupt Gate corresponds to a ISR. The structure of Interrupt Gate is shown below.</p>
<center><img align="center" src="/images/InterruptGate.svg"></center>

<h2 id="GDT-Global-Descriptor-Table"><a href="#GDT-Global-Descriptor-Table" class="headerlink" title="GDT (Global Descriptor Table)"></a>GDT (Global Descriptor Table)</h2><p>In the system, there is only one GDT. GDT stores the LDT and TSS of all the processes. We can treat it as a directory of processes. Like IDT, GDT can also be placed in any place of the memory and its address is stored in GDTR (Global Descriptor Table Register). Using the command,</p>
<pre><code>lgdt [gdt_48]
</code></pre><p>we can write the address of GDT into GDTR. The structure of GDT is shown below.</p>
<center><img align="center" src="/images/GlobalDescriptorTable.svg"></center>


<h2 id="LDT-Local-Descriptor-Table"><a href="#LDT-Local-Descriptor-Table" class="headerlink" title="LDT (Local Descriptor Table)"></a>LDT (Local Descriptor Table)</h2><p>In fact, LDT is a segment descriptor and it is used to locate the segment of corresponding process. Every process has a LDT and all the LDTs are stroed in GDT. Because there are many LDTs in the system, we need a selector to choose the current LDT. This selector is LDTR (Local Descriptor Table Register).</p>
<p>While the system is running, all the processes will alternate use the CPU. So the value in LDTR will keep changing all the time. While process switching, we use the “lldt” command to load a new segment. Some other commands can also modify the value in LDTR, for example, “jmpi”.(When Linux 0.11 entering the protected mode, the first used command is “jmpi”)</p>
<h2 id="TSS-Task-State-Segment"><a href="#TSS-Task-State-Segment" class="headerlink" title="TSS (Task State Segment)"></a>TSS (Task State Segment)</h2><p>Each process has its own TSS, its address is stored in a segment descriptor next to LDT in GDT. TSS contains many register informations about current process and it is used to save and recover the context information.</p>
<p>In Linux 0.11, a “ljmp” command to switch the context information (this command has done many other works). “ljmp” command will put all the registers’ information into the TSS of current process, then load the register information in TSS of nest process to all the registers. At the same time, this command will change the value in LDTR, to make it point to the new sgement. </p>
<p>The structure of TSS is hown below. </p>
<center><img align="center" src="/images/TaskStateSegment.svg"></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In Linux, there are many similar concepts. This article briefly talks about the IDT (Interrupt Descriptor Table), GDT (Global Descriptor Table), LDT (Local Descriptor Table) and TSS(Task State Segment).
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Paging</title>
    <link href="http://www.duzhongxiang.com/2016/09/10/Paging/"/>
    <id>http://www.duzhongxiang.com/2016/09/10/Paging/</id>
    <published>2016-09-11T01:16:18.000Z</published>
    <updated>2016-12-30T22:50:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Paging is a very important for memory management. It can help to implement virtual memory and shared memory.<a id="more"></a></p>
<p>After enabling Paging, by using “segment selector + segment offset” addressing methods, we can get a final 32-bit address. At this time, this address is not physical address. By dividing the into 3 parts, $10+10+12$, we can find the physical address. The first 10 bits are used to find the page table in the page directory, the middle 10 bits are used to find the right page in the page table and the last 12 bits are the offset in the page. So a page has $2^{12}=4$KB. Every prosess has its own page content and pages. However, in some special cases, different processes may share same pages. The address of the directory is stored in register CR3.</p>
<p><img align="center" src="/images/Paging.svg"></p>
<p>The advantage of using Paging is while we are running out of memory, we can write some pages into disk. And this contributes to the implementation of virtual memory.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paging is a very important for memory management. It can help to implement virtual memory and shared memory.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Linux" scheme="http://www.duzhongxiang.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Protected mode and Real mode</title>
    <link href="http://www.duzhongxiang.com/2016/08/21/Protected-mode-and-Real-mode/"/>
    <id>http://www.duzhongxiang.com/2016/08/21/Protected-mode-and-Real-mode/</id>
    <published>2016-08-22T06:51:02.000Z</published>
    <updated>2016-12-30T22:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Real mode and Protected mode are two kind of status of CPU. In different status, the CPU will have different addressing methods.<a id="more"></a></p>
<h2 id="Real-mode"><a href="#Real-mode" class="headerlink" title="Real mode"></a>Real mode</h2><p>In the early 8086CPU, there is only one kind of mode, the real mode. In real mode the date bus has only 16-bit and address bus has 20-bit. So the max size of each segment is $2^{16}=64$KB, and the maximum addressing range is $2^{20}=1$MB. So in practice, we use the “Segment base address + segment offset” to find the address. The segment base address is a 16-bit sgement register shifting 4 bits to left.</p>
<p>In this case, 1MB memory is devided into $2^{16}=65,536$ segments and each segment is $2^4=16$ bytes. For example, when we turn on the computer, the CS (code segment register) will be initiated as 0xFFFF, and IP (instruction pointer register) will be set as 0x0000. By shifting the CS 4 bits to the left and plus the IP, we will get CS:IP and at this time, CS:IP points to 0xFFFF0, which means the computer will run from this address.</p>
<h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>After entering the protected mode, all of the data bus, address bus and other registers of the CPU are 32 bits. Compared to the real mode, the addressing method has changed a lot. The protected mode uses the “segment selector + segment offset” to find the address. The structure of segment selector is shown below:</p>
<p><img align="center" src="/images/SegmentSelector.svg" width="311" height="165"></p>
<p>So there are at most $2^{13}$ segment selectors. In protected mode, as the segment offset is 32 bits. So, in theory, the maximum addressing range is $2^{13}\times 2^{32} \times 2=64$TB (the last two comes from the GDT and LDT). Through the segment selector we can find its segment descriptor, the structure of segment descriptor is shown below:</p>
<p><img align="center" src="/images/SegmentDescriptor.svg" width="587" height="119"></p>
<p>From segment descriptor, we can find a 32-bit base address, and then we plus the base address with a 32-bit segment offset (note: directly add up the two 32-bit register, not connect them into a 64-bit address). Then we can get the final 32-bit address. While Paging is not enabled, this address is physical address.</p>
<p>The advantage of this segmentation is that every process, has its own segment descriptor and memory space, which can strengthen the security. In some special cases, different process can share the same segment descriptor.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Real mode and Protected mode are two kind of status of CPU. In different status, the CPU will have different addressing methods.
    
    </summary>
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/categories/Operation-System/"/>
    
    
      <category term="Operation System" scheme="http://www.duzhongxiang.com/tags/Operation-System/"/>
    
  </entry>
  
</feed>
